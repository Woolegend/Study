# 세션 기반 인증과 토큰 기반 인증 비교

웹 애플리케이션에서 사용자 인증을 구현하는 두 가지 주요 방식으로는 세션 기반 인증과 토큰 기반 인증이 존재한다. 해당 문서에서는 두 방법의 특징과 장단점을 비교해보자.

## 세션 기반 인증

세션 기반 인증은 서버 측에서 사용자의 세션을 관리한다.

### 장점

- **높은 보안성**:  
  서버에서 세션을 직접 관리하므로 보안 통제가 용이하다
- **세션 무효화**:  
  필요 시 서버에서 즉시 세션을 종료할 수 있습니다
- **구현 용이성**:  
  전통적인 웹 애플리케이션에서 구현이 비교적 간단하다

### 단점

- **서버 부하**:  
  동시 접속자가 많을 경우 서버의 메모리 사용량이 증가한다.
- **확장성 제한**:  
  분산 시스템에서 세션 동기화가 어렵다

## 토큰 기반 인증

### 장점

- **서버 부하 감소**:  
  DB 접근 횟수가 줄어들어 성능 향상이 가능하다.
- **확장성**:  
  분산 시스템에서 유용하며, 서버 간 세션 동기화가 불필요하다.
- **유연성**:  
  토큰 자체에 사용자 정보와 권한을 포함할 수 있다.

### 단점

- **보안 위험**:  
  토큰이 탈취될 경우 만료 전까지 공격자가 자유롭게 서버에 요청을 보낼 수 있다.
- **토큰 관리**:  
  만료 전 토큰을 무효화하기 어렵습니다1.
- **복잡성**:  
  개발자가 암호화 알고리즘에 익숙하지 않으면 보안 위험이 있을 수 있다.

### 선택 기준

분산 시스템과 마이크로서비스 아키텍처에서는 토큰 기반 인증이 효과적이며, 반면 전통적인 단일 서버 웹 애플리케이션에서는 세션 기반 인증이 더 적합하다. 프로젝트의 우선순위에 따라 보안을 최우선으로 고려한다면 세션 기반 인증을, 확장성과 성능에 중점을 둔다면 토큰 기반 인증을 선택하는 것이 바람직하다.

두 방식 모두 장단점이 있으므로 프로젝트의 요구사항과 특성을 고려하여 적절한 인증 방식을 선택하자

# 구글 소셜 로그인 구현 과정

Authorization Code Flow와 OpenID Connect 활용

### 1. 사용자 요청

- 사용자가 웹사이트에서 '구글로 로그인' 버튼을 클릭.

### 2. 프론트엔드 동작

- 프론트엔드는 구글의 OAuth 2.0 인증 엔드포인트로 리다이렉션.
- 요청에 포함되는 매개변수:
  - 클라이언트 ID
  - 리다이렉션 URI
  - 스코프 (openid, profile 등)
  - response_type (code로 설정)
  - state (CSRF 방지용)

### 3. 구글 인증 및 권한 부여

- 사용자는 구글 로그인 페이지에서 인증.
- 인증 성공 시, 구글은 프론트엔드 리다이렉션 URI로 Authorization Code를 포함하여 리다이렉트.

### 4. 프론트엔드에서 백엔드로 코드 전달

- 프론트엔드는 받은 Authorization Code를 백엔드로 전달.

### 5. 백엔드의 토큰 요청

- 백엔드는 구글의 토큰 엔드포인트에 요청 전송.
- 요청에 포함되는 정보:
  - Authorization Code
  - 클라이언트 ID
  - 클라이언트 시크릿
  - 리다이렉션 URI

### 6. 토큰 발급

- 구글은 백엔드에 액세스 토큰과 ID 토큰 발급.

### 7. 사용자 정보 획득

- 백엔드는 발급받은 액세스 토큰을 사용하여 구글 API를 호출하여 사용자 정보 조회.
- ID 토큰을 복호화하여 사용자의 신원 정보 확인.

### 8. 로그인 완료

- 백엔드는 획득한 사용자 정보를 바탕으로 로그인 프로세스 완료.
- 필요한 경우 자체 세션 생성.
